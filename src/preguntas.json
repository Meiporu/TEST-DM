[
  {
    "question": "¿Cuál de las siguientes opciones declara correctamente una variable inmutable en Kotlin?",
    "options": [
      "var name = \"John\"",
      "let name = \"John\"",
      "val name = \"John\"",
      "const name = \"John\""
    ],
    "correct": 2
  },
  {
    "question": "¿Cuáles de las siguientes afirmaciones sobre la seguridad frente a nulos en Kotlin son verdaderas?",
    "options": [
      "Las variables no aceptan null por defecto",
      "El operador Elvis (?:) puede usarse para dar un valor por defecto",
      "Se puede asignar null a cualquier variable sin restricciones",
      "El operador !! fuerza la aserción de no nulo"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué imprimirá este código?\nval name: String? = null\nprintln(name?: \"No name provided\")",
    "options": [
      "null",
      "No name provided",
      "name",
      "Error de compilación"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál de las siguientes describe mejor la diferencia entre arrayOf y listOf en Kotlin?",
    "options": [
      "arrayOf es inmutable, listOf es mutable",
      "arrayOf admite tipos mezclados, listOf no",
      "listOf es una colección inmutable, arrayOf crea un array de tamaño fijo",
      "arrayOf es solo para enteros, listOf es genérico"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué imprimirá este código?\nval result = 3 + 5 * 2\nprintln(result)",
    "options": [
      "16",
      "13",
      "11",
      "Error de compilación"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué expresión usa correctamente el operador Elvis para proporcionar un valor por defecto?",
    "options": [
      "val result = name! \"default\"",
      "val result = name?: \"default\"",
      "val result = name ?= \"default\"",
      "val result = name else \"default\""
    ],
    "correct": 1
  },
  {
    "question": "La sentencia when en Kotlin puede reemplazar múltiples condiciones if/else.",
    "options": [
      "Verdadero",
      "Falso"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es la principal diferencia entre val y var en Kotlin?",
    "options": [
      "val es mutable, var es inmutable",
      "val se puede reasignar, var no",
      "val es inmutable (solo lectura), var es mutable",
      "val se usa solo en parámetros de funciones"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la forma correcta de definir una función con un parámetro por defecto en Kotlin?",
    "options": [
      "fun greet(name: String = \"User\") { ... }",
      "fun greet(String name = \"User\") { ... }",
      "fun greet(default name: String = \"User\") { ... }",
      "def greet(name: String = \"User\") { ... }"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué imprimirá esta función?\nfun double(x: Int): Int = x * 2\nprintln(double(4))",
    "options": [
      "8",
      "6",
      "4",
      "Double"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál de estas define correctamente una función de orden superior?",
    "options": [
      "fun operate(a: Int, b: Int): Int = a + b",
      "fun applyOp(a: Int, b: Int, op: (Int, Int) -> Int): Int = op(a, b)",
      "val op = { a: Int, b: Int -> a + b }",
      "fun add(a: Int, b: Int): op(Int, Int): Int = a + b"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál afirmación sobre el filtrado ansioso (eager) frente al perezoso (lazy) es verdadera?",
    "options": [
      "Los filtros ansiosos operan sobre secuencias",
      "Los filtros perezosos solo funcionan con arrays",
      "Los filtros ansiosos procesan todos los elementos inmediatamente; los perezosos posponen el cálculo hasta que es necesario",
      "Ambos son equivalentes en términos de rendimiento en Kotlin"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué imprimirá este código?\nval list = listOf(\"a\", \"bb\", \"ccc\")\nval result = list.map { it.length }\nprintln(result)",
    "options": [
      "[1, 2, 3]",
      "[\"a\", \"bb\", \"ccc\"]",
      "[a, bb, ccc]",
      "Error de compilación"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué función de Kotlin aplana una lista de listas en una sola lista?",
    "options": [
      "collapse()",
      "flatten()",
      "reduce()",
      "group()"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es una definición compacta de una función que devuelve la suma de dos enteros?",
    "options": [
      "fun add(a: Int, b: Int): Int = a + b",
      "fun add(a: Int, b: Int) = println(a + b)",
      "add = (a, b) -> a + b",
      "function add(a, b) { return a + b }"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué imprimirá este código?\nval list = listOf(1, 2, 3, 4, 5)\nval even = list.filter { it % 2 == 0 }\nprintln(even)",
    "options": [
      "[2, 4]",
      "[1, 3, 5]",
      "2, 4",
      "Error: filter no está disponible"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué imprimirá este código?\nclass User(val name: String) {\n    init {\n        println(\"User created: $name\")\n    }\n}\nval u = User(\"Alice\")",
    "options": [
      "Nada",
      "User created: Alice",
      "Error de compilación",
      "null"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es el propósito del bloque init en Kotlin?",
    "options": [
      "Para inicializar propiedades o ejecutar lógica en el momento de crear una instancia",
      "Para declarar variables globales",
      "Para reemplazar el constructor secundario",
      "Para definir métodos estáticos"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál de las siguientes definiciones es válida para una clase que usa un constructor primario y uno secundario?",
    "options": [
      "class A(val x: Int) { constructor(): this(0) }",
      "class A { constructor(x: Int) constructor() }",
      "class A(x: Int = 0)",
      "class A(x: Int) { constructor(x: Int = 0) }"
    ],
    "correct": 0
  },
  {
    "question": "En una clase Box con un custom getter: var size: Int = 0 get() = field + 2. Si asignas box.size = 5, ¿cuál es el problema si el valor obtenido no es el esperado?",
    "options": [
      "El getter siempre suma 2 al valor almacenado, por lo que devolverá 7",
      "El campo field no se actualiza con el valor 5",
      "Falta el setter personalizado",
      "No hay ningún problema, devolverá 5"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué palabra clave permite que una clase se pueda heredar en Kotlin?",
    "options": [
      "inherit",
      "extends",
      "open",
      "virtual"
    ],
    "correct": 2
  },
  {
    "question": "Considera: \nopen class Animal { open fun speak() = println(\"Generic sound\") }\nclass Dog : Animal() { override fun speak() = println(\"Woof\") }\n¿Qué imprimirá Dog().speak()?",
    "options": [
      "Generic sound",
      "Woof",
      "Dog",
      "Error de compilación"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué imprimirá este código?\nfun String.shout() = this.uppercase() + \"!\"\nprintln(\"hello\".shout())",
    "options": [
      "HELLO",
      "hello!",
      "HELLO!",
      "Error de compilación"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuáles de las siguientes afirmaciones sobre la palabra clave 'object' en Kotlin son correctas?",
    "options": [
      "Se usan para declarar singletons",
      "Un object puede implementar interfaces",
      "Puedes instanciar múltiples veces un object declarado con la palabra clave object",
      "Los companion object permiten acceder a miembros privados de la clase"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es una razón habitual para usar una data class en Kotlin?",
    "options": [
      "Para poder heredar de múltiples clases",
      "Para declarar objetos estáticos",
      "Para obtener automáticamente implementaciones de equals(), hashCode() y toString()",
      "Para declarar una clase abstracta"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la organización correcta para un archivo que contiene una data class, un enum y un companion object?",
    "options": [
      "Todo en un solo archivo con el paquete declarado al inicio",
      "Cada elemento debe ir obligatoriamente en un archivo distinto",
      "Los companion objects deben estar fuera de la clase",
      "Los enum no pueden estar en el mismo archivo que una data class"
    ],
    "correct": 0
  },
  {
    "question": "Quieres que la clase 'Student' sea visible solo dentro del módulo actual. ¿Qué modificador de visibilidad debes usar?",
    "options": [
      "internal",
      "private",
      "protected",
      "sealed"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es la función principal del archivo AndroidManifest.xml en una aplicación Android?",
    "options": [
      "Define el contenido del layout principal",
      "Especifica los componentes, permisos y configuraciones esenciales de la app",
      "Contiene los textos traducidos de la aplicación",
      "Declara las vistas que se usarán en la interfaz"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál de las siguientes afirmaciones sobre las Activities es correcta?",
    "options": [
      "Una aplicación debe tener exactamente una Activity",
      "Las Activities se lanzan automáticamente desde el archivo de configuración de Gradle",
      "Las Activities definen la interfaz y la lógica de una pantalla específica",
      "Las Activities se declaran únicamente en el archivo build.gradle"
    ],
    "correct": 2
  },
  {
    "question": "¿En qué directorio de recursos debe colocarse un archivo de layout XML?",
    "options": [
      "res/raw",
      "res/layout",
      "res/values",
      "res/drawable"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué se mostrará en la pantalla si un TextView tiene el atributo android:text=\"Welcome!\"?",
    "options": [
      "El texto \"Welcome!\"",
      "Nada, hasta que se asigne en el código Kotlin",
      "El ID del TextView",
      "Un error de compilación si no hay un recurso de string"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué acción realiza la línea de código: textView.text = \"New Text\"?",
    "options": [
      "Lanza una excepción si el TextView no ha sido declarado en el manifiesto",
      "Cambia el título de la aplicación",
      "Modifica el contenido mostrado por un TextView",
      "Crea un nuevo TextView en tiempo de ejecución"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál describe mejor la inicialización tardía (lateinit) en Kotlin?",
    "options": [
      "Permite declarar variables no nulas sin inicializarlas en el constructor",
      "Es una variable que no puede cambiar de valor",
      "Es equivalente a una variable declarada con lazy",
      "Se usa exclusivamente para declarar arrays"
    ],
    "correct": 0
  },
  {
    "question": "Si un botón definido en XML no realiza ninguna acción al ser pulsado, ¿cuál podría ser una causa probable?",
    "options": [
      "Falta el atributo android:onClick en el XML",
      "No se ha inflado el layout correctamente",
      "No se ha definido el listener en la Activity",
      "Todas las anteriores"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la forma correcta de asignar un listener de clic en Kotlin?",
    "options": [
      "myButton.setText(\"Click\")",
      "myButton.setOnClickListener(new OnClickListener...)",
      "myButton.setOnClickListener { ... }",
      "myButton.text = \"Click Me\""
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la función principal de Gradle en un proyecto de Android?",
    "options": [
      "Organizar los archivos XML",
      "Gestionar la compilación y las dependencias de la aplicación",
      "Ejecutar la aplicación en el dispositivo",
      "Sincronizar las actividades con el layout"
    ],
    "correct": 1
  },
  {
    "question": "En el archivo build.gradle, ¿qué indica la línea: implementation \"androidx.core:core-ktx:1.10.1\"?",
    "options": [
      "Añade una dependencia de la biblioteca de extensiones de Kotlin para Android",
      "Declara un plugin de Gradle",
      "Establece el nivel mínimo de API de la aplicación",
      "Compila los archivos de layout automáticamente"
    ],
    "correct": 0
  },
  {
    "question": "Si recibes el error \"cannot find symbol R\", ¿qué podría estar ocurriendo?",
    "options": [
      "Hay un error de sincronización de Gradle",
      "Existe un error en algún archivo XML de recursos",
      "Un recurso utilizado no tiene un ID asignado",
      "Cualquiera de las anteriores"
    ],
    "correct": 3
  },
  {
    "question": "¿Por qué se desaconseja el uso de layouts profundamente anidados?",
    "options": [
      "Porque aumentan la complejidad del código XML",
      "Porque consumen más recursos y ralentizan el renderizado de la interfaz",
      "Porque solo son compatibles con versiones antiguas de Android",
      "Porque ocupan más memoria en el disco"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué layout se recomienda para reducir la profundidad de la jerarquía de vistas manteniendo una alineación flexible?",
    "options": [
      "LinearLayout",
      "RelativeLayout",
      "ConstraintLayout",
      "FrameLayout"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué significa el atributo app:layout_constraintTop_toBottomOf=\"@id/header\" en un ConstraintLayout?",
    "options": [
      "Que la vista se colocará encima del elemento header",
      "Que la vista se centrará respecto al elemento header",
      "Que el borde superior de esta vista se alineará con el borde inferior de header",
      "Que se aplicará un padding relativo al header"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es el efecto de usar match_constraint (0dp) en un ConstraintLayout?",
    "options": [
      "La vista se expande para igualar al padre en cualquier caso",
      "La vista se extiende exactamente entre sus restricciones",
      "La vista se adapta automáticamente al contenido interno",
      "La vista se centra automáticamente"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué estilo de cadena (chain) se aplica si usas layout_constraintHorizontal_chainStyle=\"packed\"?",
    "options": [
      "Los elementos se distribuyen uniformemente",
      "Los elementos se extienden a lo largo de todo el contenedor",
      "Los elementos se agrupan estrechamente en el centro",
      "Los elementos se alinean respecto a su línea base"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la diferencia fundamental entre margen (margin) y relleno (padding)?",
    "options": [
      "El margen es espacio fuera de la vista; el relleno es espacio dentro de la vista",
      "No hay diferencia, ambos se usan para lo mismo",
      "El relleno solo se aplica en layouts",
      "El margen aumenta el tamaño total de la vista"
    ],
    "correct": 0
  },
  {
    "question": "¿Por qué se recomienda usar dp (densidad independiente) en lugar de px (píxeles) para definir el tamaño de las vistas?",
    "options": [
      "Para asegurar la compatibilidad con archivos XML",
      "Para permitir una alineación exacta de píxeles",
      "Para que la interfaz se adapte correctamente a diferentes densidades de pantalla",
      "Para desactivar el autoescalado de Android"
    ],
    "correct": 2
  },
  {
    "question": "En el contexto de data binding, ¿qué significa la sintaxis @{user.name}?",
    "options": [
      "Es una sintaxis inválida",
      "Asigna el valor de user.name a la propiedad de la vista",
      "Crea un binding bidireccional entre la vista y la variable user.name",
      "Solo se usa para binding bidireccional"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es el rol del RecyclerView.Adapter?",
    "options": [
      "Se encarga de dibujar las vistas en la pantalla",
      "Gestiona la creación y el enlace de las vistas con los datos de la lista",
      "Define el layout de cada elemento individual",
      "Reemplaza al layout manager"
    ],
    "correct": 1
  },
  {
    "question": "Un RecyclerView se carga pero no muestra datos. ¿Qué deberías revisar?",
    "options": [
      "Si se ha asignado un LayoutManager",
      "Si la implementación de onBindViewHolder es correcta",
      "Si la lista de datos está vacía",
      "Todas las anteriores"
    ],
    "correct": 3
  },
  {
    "question": "¿Qué es el reciclado de vistas en un RecyclerView?",
    "options": [
      "Destruye las vistas antiguas para liberar memoria",
      "Reutiliza las vistas que ya no son visibles para mostrar nuevos elementos",
      "Reordena la lista de elementos automáticamente",
      "Crea un ID dinámico para cada vista"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es la diferencia fundamental entre un intent explícito y uno implícito?",
    "options": [
      "Los explícitos requieren permisos especiales",
      "Los implícitos solo funcionan dentro de la misma aplicación",
      "Los explícitos apuntan a un componente específico; los implícitos describen una acción",
      "Los implícitos se usan solo para fragments"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué sucede al ejecutar: \nval intent = Intent(context, DetailActivity::class.java)\nintent.putExtra(\"EXTRA_ID\", 42)\nstartActivity(intent)?",
    "options": [
      "Se inicia la actividad actual con nuevos parámetros",
      "Falla si la actividad no está declarada en el manifiesto",
      "Inicia DetailActivity y le pasa el valor 42",
      "Lanza una aplicación externa"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué tipo de intent se utilizaría para abrir una página web en el navegador del dispositivo?",
    "options": [
      "Un intent explícito",
      "Un intent implícito con ACTION_VIEW y el URI de la web",
      "Un intent con un extra de tipo web",
      "Un intent con el permiso INTERNET activado"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es el propósito de un Navigation Host en Jetpack Navigation?",
    "options": [
      "Inflar la jerarquía de vistas",
      "Gestionar los recursos de la aplicación",
      "Define el layout de la actividad principal",
      "Sirve como contenedor para los destinos de fragmentos definidos en el grafo"
    ],
    "correct": 3
  },
  {
    "question": "¿Qué ocurre internamente al ejecutar findNavController().navigate(R.id.action_list_to_detail)?",
    "options": [
      "La aplicación se cierra",
      "El controlador reemplaza el grafo de navegación",
      "El controlador añade el nuevo fragmento al back stack",
      "Se reinicia la actividad principal"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuáles son los beneficios de usar Safe Args en la navegación?",
    "options": [
      "Permite validación en tiempo de compilación y tipado seguro para los argumentos",
      "Facilita la gestión del back stack",
      "Elimina la necesidad de usar findNavController()",
      "Añade animaciones automáticas"
    ],
    "correct": 0
  },
  {
    "question": "¿Cómo se obtiene un argumento pasado a un fragmento mediante Safe Args?",
    "options": [
      "arguments?.getInt(\"userId\")",
      "requireArguments().getInt(\"userId\")",
      "UserFragmentArgs.fromBundle(requireArguments()).userId",
      "findNavController().currentDestination.id"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la forma correcta de pasar argumentos entre destinos usando Safe Args?",
    "options": [
      "Creando un Bundle manualmente",
      "Usando la clase de dirección autogenerada (ej. HomeFragmentDirections)",
      "Declarando las variables en el manifiesto",
      "Usando variables globales"
    ],
    "correct": 1
  },
  {
    "question": "Un DrawerLayout con un NavigationView no se despliega al pulsar el icono de hamburguesa. ¿Qué deberías comprobar?",
    "options": [
      "Si el menú XML existe",
      "Si el DrawerLayout es el layout raíz",
      "Si el NavigationView tiene un menú asociado en el atributo app:menu",
      "Si los fragmentos extienden de AppCompatActivity"
    ],
    "correct": 2
  },
  {
    "question": "¿Cómo gestiona Android el back stack cuando se utiliza el Navigation Component?",
    "options": [
      "Reemplaza el fragmento anterior sin guardarlo",
      "Mantiene un back stack automático que permite volver atrás con el botón del sistema",
      "Solo permite volver atrás si se define manualmente en el grafo",
      "Reinicia el activity stack cada vez que se navega"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuándo es recomendable usar fragments en lugar de múltiples actividades?",
    "options": [
      "Para reutilizar componentes de interfaz en distintas partes de la pantalla",
      "Para aislar la lógica de negocio",
      "Para usar ViewModel exclusivamente",
      "Para evitar el uso de intents"
    ],
    "correct": 0
  },
  {
    "question": "Deseas implementar una interfaz que muestre una lista a la izquierda y detalles a la derecha en tablets. ¿Qué patrón de diseño es el más adecuado?",
    "options": [
      "DrawerLayout",
      "Navegación inferior",
      "Maestro-detalle (Master-Detail)",
      "Encadenamiento de vistas"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es el orden correcto de ejecución de los métodos del ciclo de vida al crear una actividad?",
    "options": [
      "onStart -> onCreate -> onResume",
      "onCreate -> onStart -> onResume",
      "onResume -> onStart -> onCreate",
      "onCreate -> onResume -> onStart"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué método del ciclo de vida se ejecuta justo antes de que la actividad sea destruida?",
    "options": [
      "onPause",
      "onStop",
      "onDestroy",
      "onRestart"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuáles de estos métodos se ejecutan obligatoriamente cuando el usuario rota el dispositivo?",
    "options": [
      "onPause",
      "onCreate",
      "onDestroy",
      "Todas las anteriores"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué acción realiza la función Log.d(\"MainActivity\", \"Activity started\")?",
    "options": [
      "Muestra un mensaje de alerta (Toast)",
      "Escribe un mensaje en el Logcat con la etiqueta MainActivity",
      "Lanza una excepción controlada",
      "Abre una nueva actividad de depuración"
    ],
    "correct": 1
  },
  {
    "question": "¿Por qué es preferible usar Log.d() sobre Log.e() para mensajes informativos?",
    "options": [
      "Porque Log.d() muestra el mensaje en la pantalla del usuario",
      "Para separar mensajes de depuración de errores reales en el Logcat",
      "Porque Log.e() solo funciona en versiones de producción",
      "Porque Log.d() reinicia la actividad automáticamente"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuáles son los estados del ciclo de vida exclusivos de los fragments (que no tienen las actividades)?",
    "options": [
      "onAttach, onCreateView, onDetach",
      "onCreate, onResume, onDestroy",
      "onStart, onStop",
      "Ninguno de los anteriores"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué ocurre con un fragmento si el usuario pulsa el botón \"volver\" y dicho fragmento está en la pila (back stack)?",
    "options": [
      "La actividad se cierra",
      "El fragmento se destruye y se elimina de la pantalla",
      "Se borra toda la pila de fragmentos",
      "Se sale de la aplicación"
    ],
    "correct": 1
  },
  {
    "question": "Completa la frase: \"Para añadir un fragmento a la pila de retroceso, se debe llamar a...\"",
    "options": [
      "addBackStack(\"tag\")",
      "addToBackStack(null)",
      "setArguments()",
      "saveInstanceState()"
    ],
    "correct": 1
  },
  {
    "question": "Si lanzas la secuencia de fragmentos A -> B -> C y el usuario pulsa el botón de retroceso dos veces, ¿en qué estado quedará la aplicación?",
    "options": [
      "Volverá al fragmento A",
      "Cerrará la aplicación",
      "Se quedará en el fragmento C",
      "Lanzará de nuevo el fragmento B"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es el propósito de LifecycleObserver en Android?",
    "options": [
      "Interceptar todos los eventos del sistema",
      "Permitir que una clase reciba callbacks de los eventos del ciclo de vida",
      "Monitorizar el estado del ViewModel",
      "Evitar que se ejecute onDestroy"
    ],
    "correct": 1
  },
  {
    "question": "¿Cómo se puede modificar el comportamiento del botón de retroceso en un fragmento?",
    "options": [
      "Sobrescribiendo onBackPressed en la actividad",
      "Implementando un OnBackPressedCallback",
      "Eliminando el fragmento en onPause",
      "Deshabilitando el botón en el XML"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál de las siguientes es un ejemplo de un \"short-term hack\" que debería evitarse según la arquitectura recomendada?",
    "options": [
      "Usar LiveData en el ViewModel",
      "Actualizar la interfaz directamente desde el repositorio",
      "Observar LiveData en el Fragment",
      "Utilizar Safe Args para pasar IDs"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué problema fundamental soluciona el uso de ViewModel?",
    "options": [
      "Previene la pérdida de datos cuando ocurre un cambio de configuración (como rotar la pantalla)",
      "Elimina la necesidad de usar Activities",
      "Sustituye por completo al patrón MVC",
      "Reemplaza el uso de los fragments"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuánto tiempo dura la instancia de un ViewModel?",
    "options": [
      "Hasta que termina el proceso de la app",
      "Hasta que se produce una rotación de pantalla",
      "Hasta que la actividad o el fragmento asociado finalizan definitivamente",
      "Hasta que el fragmento se desacopla (onDetach)"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué importación es necesaria para usar la delegación 'by viewModels()' en un Fragment?",
    "options": [
      "import androidx.fragment.app.viewModels",
      "annotation ViewModelScoped",
      "import android.lifecycle.ViewModel",
      "annotation InjectViewModel"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál de las siguientes afirmaciones sobre LiveData es correcta?",
    "options": [
      "Solo puede ser observado por actividades",
      "Es una clase que notifica cambios a los observadores activos y es consciente del ciclo de vida",
      "Siempre se ejecuta en el hilo principal",
      "Pierde su valor tras una rotación de pantalla"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué método se utiliza para observar un objeto LiveData dentro de un Fragment?",
    "options": [
      "observeForever",
      "watch",
      "observe",
      "subscribe"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la diferencia entre LiveData y MutableLiveData?",
    "options": [
      "MutableLiveData puede modificarse, mientras que LiveData es de solo lectura para el observador",
      "LiveData permite la escritura de datos",
      "MutableLiveData solo se puede usar para lectura",
      "No hay ninguna diferencia"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es un ejemplo válido de cómo mostrar un valor de un ViewModel en un archivo de layout (usando data binding)?",
    "options": [
      "@{viewModel.getValue()}",
      "@{viewModel.value}",
      "android:text=\"@{viewModel.counter}\"",
      "android:text=\"@{viewModel.counter.value}\""
    ],
    "correct": 2
  },
  {
    "question": "¿En qué escenario es necesario usar el binding bidireccional (@={...})?",
    "options": [
      "Para mostrar el nombre de un usuario",
      "Para leer y escribir el contenido de un EditText directamente en el ViewModel",
      "Para mostrar la hora actual",
      "Para asignar un valor constante a una vista"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué mecanismo se usa para transformar un LiveData<Long> en una fecha formateada antes de mostrarlo?",
    "options": [
      "MediatorLiveData",
      "Transformations.map",
      "ViewBinding",
      "NavArgs"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuáles son los beneficios de separar la interfaz de los datos mediante el uso de ViewModel y LiveData?",
    "options": [
      "Mejora la reutilización del código y evita dependencias directas de la UI",
      "Elimina la necesidad de usar XML",
      "Permite que la interfaz acceda directamente a la base de datos",
      "Todas las anteriores"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál de las siguientes es una forma NO recomendada de almacenar datos persistentes en Android?",
    "options": [
      "Usar SharedPreferences",
      "Almacenamiento en archivos internos",
      "Conexión JDBC directa a una base de datos en la nube desde la actividad",
      "Usar la biblioteca de persistencia Room"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué define la anotación @Entity en Room?",
    "options": [
      "Un objeto DAO con funciones suspend",
      "Una clase que representa una tabla en la base de datos SQLite",
      "Un método de consulta SQL",
      "El esquema de configuración XML"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es el propósito de la interfaz DAO en Room?",
    "options": [
      "Gestionar la navegación entre pantallas",
      "Generar archivos XML automáticamente",
      "Abstraer y definir las operaciones de acceso a la base de datos (CRUD)",
      "Gestionar el ciclo de vida de la aplicación"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué ocurre si declaras un método con @Query como suspend en un DAO?",
    "options": [
      "El método bloqueará la interfaz de usuario",
      "Room ejecutará la consulta automáticamente en un hilo de segundo plano",
      "El método solo podrá llamarse dentro de una corrutina o de otra función suspend",
      "Dará un error de compilación"
    ],
    "correct": 2
  },
  {
    "question": "¿Por qué es preferible usar corrutinas de Kotlin al realizar operaciones con la base de datos?",
    "options": [
      "Porque evitan el bloqueo del hilo principal de la interfaz y se integran bien con el ViewModel",
      "Porque permiten crear DAOs automáticamente",
      "Porque solo funcionan con almacenamiento externo",
      "Porque reemplazan el uso de SQL"
    ],
    "correct": 0
  },
  {
    "question": "¿Para qué sirve el bloque withContext(Dispatchers.IO)?",
    "options": [
      "Para ejecutar código intensivo de CPU",
      "Para lanzar una corrutina en la interfaz de usuario",
      "Para cambiar el contexto de ejecución a hilos optimizados para operaciones de entrada/salida",
      "Para cancelar una corrutina en ejecución"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la forma correcta de lanzar una corrutina desde un ViewModel?",
    "options": [
      "CoroutineScope.launch { ... }",
      "runBlocking { ... }",
      "viewModelScope.launch { ... }",
      "GlobalScope.launch { ... }"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué hace el parámetro onConflict = OnConflictStrategy.REPLACE en la anotación @Insert?",
    "options": [
      "Evita que se inserten duplicados lanzando un error",
      "Aborta la transacción si hay un conflicto",
      "Reemplaza la fila existente si hay un conflicto de clave primaria",
      "Elimina toda la tabla antes de insertar"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la definición correcta de una entidad de Room para representar un Libro (Book)?",
    "options": [
      "data class Book(val id: Int, val title: String)",
      "@Entity data class Book(@PrimaryKey(autoGenerate = true) val id: Int, val title: String)",
      "class Book { val id: Int; val title: String }",
      "data class Book(@Entity val id: Int)"
    ],
    "correct": 1
  },
  {
    "question": "¿Cómo se debe inicializar una base de datos Room en el código de la aplicación?",
    "options": [
      "Usando SQLiteOpenHelper directamente",
      "Llamando a Room.databaseBuilder()",
      "Mediante una consulta SQL raw",
      "Instanciando directamente el objeto DAO"
    ],
    "correct": 1
  },
  {
    "question": "¿Por qué es útil utilizar una base de datos en memoria para las pruebas unitarias?",
    "options": [
      "Porque es más rápida y no deja restos de datos en el dispositivo",
      "Porque evita operaciones de entrada/salida en el disco",
      "Porque permite el aislamiento completo entre ejecuciones de pruebas",
      "Todas las anteriores"
    ],
    "correct": 3
  },
  {
    "question": "¿Qué función se utiliza para probar un método suspend de un DAO en un entorno de test?",
    "options": [
      "withContext",
      "runTest",
      "viewModelScope.launch",
      "launchInScope"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es la principal ventaja de ListAdapter frente a un RecyclerView.Adapter estándar?",
    "options": [
      "Permite añadir cabeceras más fácilmente",
      "Calcula automáticamente las diferencias en la lista usando DiffUtil en un hilo secundario",
      "No requiere el uso de ViewHolders",
      "Permite actualizaciones en tiempo constante"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué hace la clase DiffUtil.ItemCallback?",
    "options": [
      "Determina si dos elementos de la lista y sus contenidos son idénticos",
      "Define la cantidad máxima de elementos",
      "Define el layout que se debe usar",
      "Crea una base de datos en memoria temporal"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué debe pasarse al constructor del ViewHolder cuando se usa data binding en el RecyclerView?",
    "options": [
      "La vista raíz (View)",
      "El LayoutInflater",
      "La clase de binding generada (ej. ItemLayoutBinding)",
      "Un objeto LiveData"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es el rol de un binding adapter en Android?",
    "options": [
      "Cargar datos de la red",
      "Convertir las vistas en fragmentos",
      "Permite ejecutar lógica personalizada al enlazar propiedades en el XML",
      "Gestionar el ciclo de vida del adaptador"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué hace la anotación @BindingAdapter(\"imageUrl\")?",
    "options": [
      "Define el texto de un TextView",
      "Infla el archivo de layout automáticamente",
      "Carga una imagen en un TextView",
      "Define un atributo personalizado app:imageUrl utilizable en el XML"
    ],
    "correct": 3
  },
  {
    "question": "Deseas implementar un RecyclerView que muestre cabeceras y elementos. ¿Qué pasos seguirías?",
    "options": [
      "Definir múltiples tipos de vista, sobrescribir onCreateViewHolder para inflar distintos layouts y usar getItemViewType",
      "Solo se puede hacer usando DiffUtil",
      "No es posible mezclar tipos de vista en un RecyclerView",
      "Usar un LinearLayout para cada fila"
    ],
    "correct": 0
  },
  {
    "question": "¿Cómo puedes convertir una lista de elementos en una cuadrícula (grid) en un RecyclerView?",
    "options": [
      "Usando un GridLayoutManager",
      "Activando el modo grid en el XML",
      "Cambiando el layout raíz a ConstraintLayout",
      "Cambiando la propiedad span de la vista"
    ],
    "correct": 0
  },
  {
    "question": "¿Cómo se pueden definir diferentes tamaños de columna (span) para elementos específicos (como cabeceras) en un Grid?",
    "options": [
      "Usando un LinearLayoutManager",
      "Ajustando los LayoutParams del elemento",
      "Configurando un SpanSizeLookup personalizado en el GridLayoutManager",
      "Usando pesos (weights) en el XML"
    ],
    "correct": 2
  },
  {
    "question": "Si cambias la ordenación de una lista en el RecyclerView pero no se refleja en pantalla, ¿qué podrías haber olvidado?",
    "options": [
      "Llamar a submitList() con la nueva lista ordenada",
      "Definir un ViewHolder",
      "Reiniciar la lista de datos",
      "Cambiar el LayoutManager"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es la condición habitual para retornar VIEW_TYPE_HEADER en getItemViewType()?",
    "options": [
      "Si position % 2 == 0",
      "Si el objeto en la posición de la lista es una instancia de Header",
      "Si la posición es igual a -1",
      "Si el contenido es null"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué beneficio de rendimiento aporta el uso conjunto de ListAdapter y DiffUtil?",
    "options": [
      "Redibuja toda la lista en cada cambio",
      "Actualiza únicamente los elementos que han cambiado de forma eficiente",
      "Evita el uso de ViewHolders",
      "Elimina la necesidad de un LayoutManager"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué permiso debe añadirse al AndroidManifest.xml para realizar peticiones a internet?",
    "options": [
      "android.permission.WIFI_ACCESS",
      "android.permission.INTERNET",
      "android.permission.ACCESS_NETWORK",
      "android.permission.INTERNET_ACCESS"
    ],
    "correct": 1
  },
  {
    "question": "¿Por qué el permiso de internet se concede automáticamente mientras que el de la cámara requiere permiso en tiempo de ejecución?",
    "options": [
      "Todos los permisos son en tiempo de ejecución",
      "Internet solo se permite en el sistema",
      "Debido al nivel de protección (permisos normales vs peligrosos)",
      "Porque internet requiere acceso root"
    ],
    "correct": 2
  },
  {
    "question": "Si recibes la excepción NetworkOnMainThreadException, ¿cuál es el problema?",
    "options": [
      "La URL no es válida",
      "Estás intentando realizar una operación de red en el hilo principal de la UI",
      "No has usado un ViewModel",
      "El servidor no responde a la petición GET"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuáles son los componentes clave necesarios para configurar Retrofit?",
    "options": [
      "Una URL base, una interfaz anotada y un JSON converter factory",
      "Un objeto DAO y un repositorio",
      "Un archivo XML de configuración",
      "Una instancia de SharedPreferences"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué anotación se usa en Retrofit para definir una petición GET?",
    "options": [
      "@Request",
      "@HttpGet",
      "@GET",
      "@getRequest"
    ],
    "correct": 2
  },
  {
    "question": "¿Cómo se consigue que Retrofit convierta automáticamente los resultados JSON en clases de Kotlin?",
    "options": [
      "Implementando un DAO",
      "Añadiendo un convertidor como Moshi o Gson al constructor de Retrofit",
      "Usando un MutableLiveData",
      "Cargando los datos en un LiveData"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué es Moshi en el desarrollo de Android?",
    "options": [
      "Un reemplazo para Retrofit",
      "Un planificador de corrutinas",
      "Una librería de serialización/deserialización de JSON para Kotlin/Java",
      "Un emulador de servidor"
    ],
    "correct": 2
  },
  {
    "question": "Si tienes @GET(\"users\") suspend fun getUsers(): List<User>, ¿cuál es el tipo de retorno real que maneja la corrutina?",
    "options": [
      "Call<List<User>>",
      "Deferred<List<User>>",
      "LiveData<List<User>>",
      "List<User>"
    ],
    "correct": 3
  },
  {
    "question": "Completa la llamada típica de Glide: Glide.with(context).load(url).into(...)",
    "options": [
      "context",
      "url",
      "imageView",
      "drawable"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es el propósito del método placeholder() en Glide?",
    "options": [
      "Define el tamaño de la imagen",
      "Muestra una imagen temporal mientras se carga la imagen real",
      "Aplica un filtro de color",
      "Establece la URL base"
    ],
    "correct": 1
  },
  {
    "question": "¿En qué archivo se deben agregar las dependencias de Glide o Retrofit?",
    "options": [
      "AndroidManifest.xml",
      "gradle.properties",
      "build.gradle (Module: app)",
      "strings.xml"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál de las siguientes es una buena práctica al realizar operaciones de red?",
    "options": [
      "Declarar el permiso INTERNET y realizar las peticiones fuera del hilo principal",
      "Pedir el permiso de internet en tiempo de ejecución",
      "Evitar el uso de librerías como Retrofit",
      "Bloquear la interfaz hasta recibir los datos"
    ],
    "correct": 0
  },
  {
    "question": "¿Cuál es el propósito del patrón de repositorio en Android?",
    "options": [
      "Gestionar la navegación entre fragmentos",
      "Separar el manejo de las fuentes de datos del resto de la lógica de la aplicación",
      "Actualizar los layouts automáticamente",
      "Ejecutar corrutinas en el hilo principal"
    ],
    "correct": 1
  },
  {
    "question": "¿Por qué es recomendable cachear los datos de red en un repositorio local?",
    "options": [
      "Para reducir el consumo de RAM",
      "Para evitar errores de compilación",
      "Para mejorar el rendimiento y permitir el acceso offline",
      "Para delegar la lógica de negocio"
    ],
    "correct": 2
  },
  {
    "question": "¿Cómo suele exponer los datos un repositorio al ViewModel?",
    "options": [
      "Lanzando corrutinas sin tipo de retorno",
      "Iniciando una actividad por cada fuente de datos",
      "Utilizando LiveData o Flow",
      "Usando Retrofit directamente en la interfaz"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué clase se debe extender para implementar una tarea con WorkManager que soporte corrutinas?",
    "options": [
      "Worker",
      "AsyncTask",
      "CoroutineWorker",
      "BackgroundService"
    ],
    "correct": 2
  },
  {
    "question": "¿En qué escenario es preferible usar WorkManager en lugar de corrutinas simples?",
    "options": [
      "Para tareas que deben persistir tras el reinicio de la app y respetar restricciones del sistema",
      "Para realizar animaciones complejas",
      "Para operaciones rápidas que solo ocurren en memoria",
      "Para actualizar un TextView cada segundo"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué parámetros se pueden configurar al crear un OneTimeWorkRequest?",
    "options": [
      "Solo el Worker a ejecutar",
      "El Intent de la actividad",
      "Datos de entrada (input data) y restricciones (constraints)",
      "El ViewModel asociado"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué debe retornar la función doWork() en un Worker?",
    "options": [
      "Boolean",
      "Unit",
      "Una cadena con el estado",
      "Un objeto Result (Success, Failure o Retry)"
    ],
    "correct": 3
  },
  {
    "question": "¿Cómo se encola una tarea que se debe ejecutar periódicamente?",
    "options": [
      "Llamando a enqueue(OneTimeWorkRequest)",
      "Llamando a enqueue(PeriodicWorkRequest)",
      "Usando scheduleWithDelay",
      "Usando postDelayed"
    ],
    "correct": 1
  },
  {
    "question": "Deseas que una tarea de red solo se ejecute si el dispositivo tiene batería suficiente. ¿Cómo lo configurarías?",
    "options": [
      "Usando setInitialDelay",
      "Usando setBackoffCriteria",
      "Usando Constraints.Builder().setRequiresBatteryNotLow(true)",
      "Usando Thread.sleep"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es la diferencia entre un OneTimeWorkRequest y un PeriodicWorkRequest?",
    "options": [
      "OneTime se repite indefinidamente",
      "OneTime se ejecuta una sola vez; Periodic se ejecuta en intervalos regulares",
      "Periodic se usa para tareas de interfaz",
      "Solo OneTime permite usar restricciones"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué ventaja ofrece WorkManager sobre AlarmManager para tareas de fondo?",
    "options": [
      "Ofrece condiciones de ejecución flexibles y gestión automática de persistencia y reintentos",
      "Es más eficiente para tareas de primer plano",
      "Permite acceder al almacenamiento externo",
      "Se ejecuta en el hilo principal"
    ],
    "correct": 0
  },
  {
    "question": "Si aplicas un atributo de diseño en la línea del XML y un estilo al mismo elemento, ¿cuál prevalece?",
    "options": [
      "El estilo sobrescribe al atributo de línea",
      "El atributo de línea tiene prioridad sobre el estilo",
      "El comportamiento es indefinido",
      "Solo se aplica lo definido en el tema"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es la diferencia entre un Estilo y un Tema en Android?",
    "options": [
      "Un Estilo se aplica a vistas individuales; un Tema se aplica a nivel global de app o actividad",
      "Un Tema solo se usa para animaciones",
      "Un Estilo se define en código Kotlin y un Tema en XML",
      "No hay diferencia, son términos intercambiables"
    ],
    "correct": 0
  },
  {
    "question": "¿Dónde se suelen definir los recursos de color y dimensiones para que sean reutilizables?",
    "options": [
      "En res/values (colors.xml y dimens.xml)",
      "En el archivo de manifiesto",
      "Dentro de la clase MainActivity",
      "En archivos .kt separados"
    ],
    "correct": 0
  },
  {
    "question": "¿Qué unidad se recomienda para definir el tamaño de las fuentes por motivos de accesibilidad?",
    "options": [
      "px",
      "dp",
      "sp",
      "pt"
    ],
    "correct": 2
  },
  {
    "question": "¿Cómo se aplica un estilo de texto definido en el tema a un TextView?",
    "options": [
      "Usando @android:style",
      "style=\"@style/TextAppearance.AppCompat.Body1\"",
      "android:text=\"@theme/TextSize\"",
      "android:textSize=\"TextSize.Hello\""
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es el propósito de TextAppearance?",
    "options": [
      "Definir colores de fondo",
      "Permite aplicar estilos específicos de texto (tamaño, fuente, color) de forma modular",
      "Gestionar las animaciones de entrada",
      "Configurar los recursos de cadenas"
    ],
    "correct": 1
  },
  {
    "question": "¿Cuál es el propósito de las bibliotecas de Material Components en Android?",
    "options": [
      "Implementar la lógica de negocio",
      "Cargar datos de red",
      "Construir interfaces usando principios de Material Design",
      "Implementar persistencia con Room"
    ],
    "correct": 2
  },
  {
    "question": "¿Cuál es el método correcto para mostrar un Snackbar en un fragmento?",
    "options": [
      "Snackbar.show(requireContext())",
      "Snackbar.display(\"Mensaje\")",
      "Snackbar.make(requireView(), \"Mensaje\", Snackbar.LENGTH_SHORT).show()",
      "Snackbar.toast(requireActivity(), \"Mensaje\")"
    ],
    "correct": 2
  },
  {
    "question": "¿Qué componentes de Material Design se usan comúnmente para la interacción con el usuario?",
    "options": [
      "FloatingActionButton, Snackbar, CardView",
      "ViewModel",
      "RecyclerView",
      "Activity"
    ],
    "correct": 0
  },
  {
    "question": "¿Por qué deberías proporcionar recursos alternativos para dimensiones, layouts o cadenas de texto?",
    "options": [
      "Para reducir el tamaño del APK",
      "Para facilitar la depuración de la app",
      "Para mejorar la compatibilidad con distintos idiomas, tamaños de pantalla y configuraciones",
      "Para cumplir con las directrices de Google Play"
    ],
    "correct": 2
  },
  {
    "question": "¿Cómo defines recursos de cadenas alternativos para la localización en español?",
    "options": [
      "res/strings-spanish.xml",
      "res/values-es/strings.xml",
      "res/locale/es/strings.xml",
      "res/intl/strings-es.xml"
    ],
    "correct": 1
  },
  {
    "question": "¿Qué debes hacer para dar soporte a idiomas con escritura de derecha a izquierda (RTL) en tu layout?",
    "options": [
      "Usar start/end en lugar de left/right en los atributos de diseño",
      "Reescribir todos los layouts para cada idioma",
      "Usar estilos diferentes por idioma",
      "Invertir todas las imágenes de la aplicación"
    ],
    "correct": 0
  }
]